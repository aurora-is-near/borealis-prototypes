syntax = "proto3";

import "blocksapi/message.proto";

option go_package = "github.com/aurora-is-near/borealis-prototypes/go/blocksapi;blocksapi";

message BlockStreamFilter {
    bool exclude_shards = 1;
    repeated uint64 filter_shards = 2;
    
    // TODO:
    // - filter by account(s)
    // - other criterias
    // - different filter modes maybe? (AND/OR/etc)
    // IMHO all of this is excessive on first iteration
}

message BlockStreamDeliverySettings {
    BlockStreamFilter filter = 1;
    BlockMessageDeliverySettings content = 2;
}

message GetBlockStreamRequest {

    // Defines initial stream seek behavior for given target message ID
    enum StartPolicy {
        // Start on earliest available message
        ON_EARLIEST_AVAILABLE = 0;
        // Start on latest available message
        ON_LATEST_AVAILABLE = 1;
        // Start exactly on target, return error if no such target
        EXACTLY_ON_TARGET = 2;
        // Start on message which comes exactly after target, return error if no such target
        EXACTLY_AFTER_TARGET = 3;
        // Start on earliest available message that is greater or equal to target
        ON_CLOSEST_TO_TARGET = 4;
        // Start on earliest available message that is strictly greater than target
        ON_EARLIEST_AFTER_TARGET = 5;
    }

    // Defines how service should behave if start target is not yet available
    enum CatchupPolicy {
        // Return error if catch up needed
        PANIC = 0;
        // Don't send anything until catch up
        WAIT = 1;
        // Stream normally from whatever is available before start target
        STREAM = 2;
    }

    // Defines when stream has to stop
    enum StopPolicy {
        // Follow new blocks
        NEVER = 0;
        // Don't send messages greater than target
        AFTER_TARGET = 1;
        // Don't send messages greater or equal to target
        BEFORE_TARGET = 2;
    }

    string stream_name = 1;

    StartPolicy start_policy = 2;
    optional BlockMessage.ID start_target = 3;

    StopPolicy stop_policy = 4;
    optional BlockMessage.ID stop_target = 5;

    BlockStreamDeliverySettings delivery_settings = 6;

    CatchupPolicy catchup_policy = 7;
    // If not provided - default delivery settings are used during catchup
    optional BlockStreamDeliverySettings catchup_delivery_settings = 8;
}

message GetBlockStreamResponse {
    message Result {
        BlockMessage message = 1;
        bool catchup_in_progress = 2;
        // TODO: maybe add auxiliary info that helps understanding distance to latest block
    }
    message Done {
        string description = 1;
        // TODO: end reason?
        // TODO: stats? etc?
        // TODO: next message id?
    }
    message Error {
        enum Kind {
            // Default error class
            UNKNOWN = 0;
            // Catch up required, but catchup policy is PANIC
            CATCHUP_REQUIRED = 1;
            // Request is constructed in a wrong way
            BAD_REQUEST = 2;
        }
        Kind kind = 1;
        string description = 2;
    }
    oneof response {
        Result message = 1;
        Done done = 2;
        Error error = 3;
    }
}
